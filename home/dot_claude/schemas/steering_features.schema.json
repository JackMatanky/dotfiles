{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "~/.claude/schemas/features.schema.json",
  "title": "Features Definition Schema",
  "description": "Schema for atomic feature definitions derived from steering documents with explicit scope boundaries and traceability.",
  "type": "object",
  "additionalProperties": false,
  "required": ["meta", "feature"],

  "properties": {
    "meta": {
      "$ref": "~/.claude/schemas/meta.schema.json"
    },

    "feature": {
      "type": "array",
      "minItems": 1,
      "maxItems": 100,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "order",
          "name",
          "id",
          "category",
          "description",
          "rationale",
          "source_reference",
          "scope",
          "acceptance_criteria",
          "metrics",
          "priority",
          "status",
          "assumptions",
          "user_impact",
          "technical_complexity",
          "testing",
          "decomposition"
        ],

        "properties": {
          "order": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "description": "Implementation sequence number for planning progression."
          },

          "name": {
            "type": "string",
            "minLength": 3,
            "maxLength": 80,
            "description": "Short, descriptive, unique human-readable title."
          },

          "id": {
            "type": "string",
            "pattern": "^[a-z0-9]+(?:-[a-z0-9]+)*$",
            "minLength": 3,
            "maxLength": 50,
            "description": "Globally unique kebab-case identifier."
          },

          "category": {
            "type": "string",
            "enum": ["product", "tech", "structure"],
            "description": "Primary domain classification aligned to steering docs."
          },

          "description": {
            "type": "string",
            "minLength": 60,
            "maxLength": 500,
            "description": "Comprehensive purpose, scope, and context with explicit boundaries."
          },

          "rationale": {
            "type": "string",
            "minLength": 30,
            "maxLength": 300,
            "description": "Why the feature exists and justification for atomic scope."
          },

          "source_reference": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "type": "string",
              "pattern": "^(product\\.toml|tech\\.toml|structure\\.toml) ยง[0-9]+(\\.[0-9]+)*$"
            },
            "description": "Exact citations to steering docs that justify this feature."
          },

          "scope": {
            "type": "object",
            "additionalProperties": false,
            "required": ["includes", "excludes", "boundaries"],
            "properties": {
              "includes": {
                "type": "array",
                "minItems": 1,
                "maxItems": 5,
                "items": {
                  "type": "string",
                  "minLength": 10,
                  "maxLength": 100
                },
                "description": "Capabilities explicitly in scope."
              },
              "excludes": {
                "type": "array",
                "minItems": 1,
                "maxItems": 5,
                "items": {
                  "type": "string",
                  "minLength": 10,
                  "maxLength": 100
                },
                "description": "Capabilities explicitly out of scope."
              },
              "boundaries": {
                "type": "object",
                "additionalProperties": false,
                "required": ["input", "output", "process", "component"],
                "properties": {
                  "input": {
                    "type": "string",
                    "minLength": 10,
                    "maxLength": 200,
                    "description": "Data/events that trigger this feature with examples."
                  },
                  "output": {
                    "type": "string",
                    "minLength": 10,
                    "maxLength": 200,
                    "description": "Results/states this feature produces with examples."
                  },
                  "process": {
                    "type": "string",
                    "minLength": 10,
                    "maxLength": 200,
                    "description": "Steps included in this feature's scope."
                  },
                  "component": {
                    "type": "string",
                    "minLength": 10,
                    "maxLength": 100,
                    "description": "System component this operates within."
                  },
                  "ui": {
                    "type": "string",
                    "minLength": 3,
                    "maxLength": 200,
                    "description": "UI elements/interactions or 'N/A' for backend."
                  },
                  "data": {
                    "type": "string",
                    "minLength": 3,
                    "maxLength": 200,
                    "description": "Data entities operated on by name, or 'N/A'."
                  },
                  "integration": {
                    "type": "string",
                    "minLength": 3,
                    "maxLength": 200,
                    "description": "External systems interacted with, or 'N/A'."
                  }
                }
              }
            }
          },

          "acceptance_criteria": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "type": "string",
              "minLength": 20,
              "maxLength": 300,
              "pattern": ".*GIVEN.*WHEN.*THEN.*",
              "description": "Testable GIVEN-WHEN-THEN format statements."
            }
          },

          "metrics": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "type": "string",
              "minLength": 20,
              "maxLength": 200,
              "pattern": ".*target.*measured.*",
              "description": "Measurable targets with measurement methods."
            }
          },

          "priority": {
            "type": "string",
            "enum": ["high", "medium", "low"],
            "description": "Urgency based on steering document goal contribution."
          },

          "status": {
            "type": "string",
            "enum": [
              "proposed",
              "approved",
              "in_progress",
              "completed",
              "deferred",
              "deprecated"
            ],
            "description": "Current lifecycle state."
          },

          "assumptions": {
            "type": "array",
            "minItems": 1,
            "maxItems": 3,
            "items": {
              "type": "string",
              "minLength": 10,
              "maxLength": 150
            },
            "description": "Preconditions required for feature execution."
          },

          "user_impact": {
            "type": "string",
            "minLength": 20,
            "maxLength": 200,
            "description": "Specific user benefit or system improvement."
          },

          "technical_complexity": {
            "type": "string",
            "enum": ["trivial", "simple", "moderate", "complex"],
            "description": "Implementation difficulty assessment."
          },

          "dependencies": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 3,
              "maxLength": 100,
              "description": "External system or 'feature:<id>' reference."
            },
            "uniqueItems": true,
            "description": "Required external systems or features."
          },

          "risks": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 20,
              "maxLength": 200,
              "pattern": ".*IF.*THEN.*MITIGATED BY.*",
              "description": "Risk in IF-THEN-MITIGATED BY format."
            },
            "description": "Notable implementation risks with mitigation."
          },

          "notes": {
            "type": "string",
            "maxLength": 500,
            "description": "Optional clarifications or constraints."
          },

          "testing": {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "unit_tests",
              "integration_tests",
              "acceptance_tests",
              "error_tests"
            ],
            "properties": {
              "unit_tests": {
                "type": "array",
                "minItems": 3,
                "maxItems": 5,
                "items": {
                  "type": "string",
                  "minLength": 20,
                  "maxLength": 200
                },
                "description": "Test cases for core logic."
              },
              "integration_tests": {
                "type": "array",
                "minItems": 2,
                "maxItems": 3,
                "items": {
                  "type": "string",
                  "minLength": 20,
                  "maxLength": 200
                },
                "description": "Test cases for system interactions."
              },
              "acceptance_tests": {
                "type": "array",
                "minItems": 1,
                "maxItems": 2,
                "items": {
                  "type": "string",
                  "minLength": 20,
                  "maxLength": 200
                },
                "description": "End-to-end workflow tests."
              },
              "error_tests": {
                "type": "array",
                "minItems": 2,
                "maxItems": 3,
                "items": {
                  "type": "string",
                  "minLength": 20,
                  "maxLength": 200
                },
                "description": "Error condition tests."
              }
            }
          },

          "decomposition": {
            "type": "object",
            "additionalProperties": false,
            "required": ["who", "what", "where", "when", "why", "how"],
            "properties": {
              "who": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "User role or system that benefits (single entity)."
              },
              "what": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "Action or outcome enabled (single capability)."
              },
              "where": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "Context or system boundary (single location)."
              },
              "when": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "Trigger or timing (single event)."
              },
              "why": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "Problem solved (single issue)."
              },
              "how": {
                "type": "string",
                "minLength": 10,
                "maxLength": 100,
                "description": "Mechanism or approach (single method)."
              }
            }
          }
        }
      }
    }
  },

  "additionalValidation": {
    "description": "Validation rules for atomic feature decomposition",
    "atomicFeatureRules": [
      "Single Responsibility: covers exactly one capability",
      "Single Sprint: implementable in 1-2 weeks by one team",
      "Independent Value: provides value without other features",
      "Clear Boundary: explainable scope in one sentence"
    ],
    "crossReferenceRules": [
      "All source_reference entries must point to actual steering document sections",
      "All feature dependencies using 'feature:<id>' must reference existing features",
      "Categories must align with primary impact domain from steering docs"
    ],
    "deduplicationRules": [
      "No field duplication between sections",
      "Scope boundaries consolidate all boundary information",
      "Metrics consolidate all measurement information",
      "Testing consolidates all test scenarios"
    ],
    "qualityRules": [
      "Acceptance criteria must use GIVEN-WHEN-THEN format",
      "Risks must use IF-THEN-MITIGATED BY format",
      "Metrics must include target and measurement method",
      "All boundaries must be concrete with examples"
    ]
  }
}
