{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "~/.claude/schemas/steering_tech.schema.json",
  "title": "Technical Steering Document Schema",
  "description": "Schema for technical steering documents in TOML format, defining technical architecture and design blueprint for spec-driven development.",
  "type": "object",
  "additionalProperties": false,
  "required": ["meta", "technical_vision", "clean_architecture_principles", "guiding_principles", "architecture_decision", "components", "technology_stack", "operational_concerns", "traceability"],

  "properties": {
    "meta": {
      "$ref": "~/.claude/schemas/meta.schema.json"
    },

    "technical_vision": {
      "type": "object",
      "additionalProperties": false,
      "required": ["architecture_approach", "architecture_rationale"],
      "properties": {
        "architecture_approach": {
          "type": "string",
          "enum": ["Layered", "Hexagonal", "Event-Driven", "Microservices", "Monolithic", "Serverless", "Domain-Driven", "Hybrid"],
          "description": "Selected high-level architecture approach"
        },
        "architecture_rationale": {
          "type": "string",
          "minLength": 25,
          "maxLength": 800,
          "description": "Detailed rationale for architecture choice with product alignment"
        }
      }
    },

    "clean_architecture_principles": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "independence_of_frameworks",
        "testability",
        "independence_of_ui",
        "independence_of_database",
        "independence_of_external_agencies",
        "dependency_rule"
      ],
      "properties": {
        "independence_of_frameworks": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How system avoids being bound to external libraries"
        },
        "testability": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How business rules are testable without UI/DB/external services"
        },
        "independence_of_ui": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How UI changes don't affect core business rules"
        },
        "independence_of_database": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How data storage may change without impacting business rules"
        },
        "independence_of_external_agencies": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How core is isolated from external tools"
        },
        "dependency_rule": {
          "type": "string",
          "minLength": 20,
          "maxLength": 300,
          "description": "How source code dependencies point inward toward core"
        }
      }
    },

    "guiding_principles": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "single_responsibility",
        "open_closed",
        "liskov_substitution",
        "interface_segregation",
        "dependency_inversion",
        "dry",
        "kiss",
        "composition_over_inheritance",
        "high_cohesion_low_coupling",
        "yagni",
        "explicit_boundaries",
        "pragmatism"
      ],
      "properties": {
        "single_responsibility": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Single Responsibility Principle"
        },
        "open_closed": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Open/Closed Principle"
        },
        "liskov_substitution": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Liskov Substitution Principle"
        },
        "interface_segregation": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Interface Segregation Principle"
        },
        "dependency_inversion": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Dependency Inversion Principle"
        },
        "dry": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Don't Repeat Yourself principle"
        },
        "kiss": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of Keep It Simple principle"
        },
        "composition_over_inheritance": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific approach to composition over inheritance"
        },
        "high_cohesion_low_coupling": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific approach to cohesion and coupling"
        },
        "yagni": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific application of You Aren't Gonna Need It"
        },
        "explicit_boundaries": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific approach to defining clear interfaces"
        },
        "pragmatism": {
          "type": "string",
          "minLength": 15,
          "maxLength": 250,
          "description": "Project-specific balance of best practices with delivery trade-offs"
        }
      }
    },

    "architecture_decision": {
      "type": "object",
      "additionalProperties": false,
      "required": ["chosen_architecture", "decision_rationale", "options"],
      "properties": {
        "chosen_architecture": {
          "type": "string",
          "minLength": 3,
          "maxLength": 50,
          "description": "Final selected architecture approach"
        },
        "decision_rationale": {
          "type": "string",
          "minLength": 30,
          "maxLength": 600,
          "description": "Detailed rationale with product alignment"
        },
        "options": {
          "type": "array",
          "minItems": 1,
          "maxItems": 5,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "option",
              "benefits",
              "risks",
              "impact_on_outcomes",
              "alignment_with_constraints",
              "operational_overhead",
              "time_to_market",
              "cost_efficiency",
              "evolutionary_flexibility",
              "recommendation_score"
            ],
            "properties": {
              "option": {
                "type": "string",
                "minLength": 3,
                "maxLength": 50,
                "description": "Architecture option name"
              },
              "benefits": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "minItems": 1,
                "maxItems": 8,
                "description": "Architecture benefits"
              },
              "risks": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "minItems": 1,
                "maxItems": 8,
                "description": "Architecture risks"
              },
              "impact_on_outcomes": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^O([1-9]|[1-9][0-9]|100)$"
                },
                "description": "Product outcome IDs this option affects"
              },
              "alignment_with_constraints": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": ["regulatory", "technical", "business", "legal", "compliance", "budget", "timeline", "resource", "security", "privacy", "accessibility", "performance", "integration", "other"]
                },
                "description": "Product constraint types this option aligns with"
              },
              "operational_overhead": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Operational complexity level"
              },
              "time_to_market": {
                "type": "string",
                "enum": ["fast", "moderate", "slow"],
                "description": "Speed to market impact"
              },
              "cost_efficiency": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Cost efficiency rating"
              },
              "evolutionary_flexibility": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Ability to adapt and scale"
              },
              "recommendation_score": {
                "type": "string",
                "enum": ["high", "medium", "low"],
                "description": "Overall recommendation level"
              }
            }
          }
        }
      }
    },

    "components": {
      "type": "array",
      "minItems": 1,
      "maxItems": 50,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["name", "responsibility", "design_patterns", "serves_personas", "maps_to_outcomes"],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 3,
            "maxLength": 80,
            "description": "Component name"
          },
          "responsibility": {
            "type": "string",
            "minLength": 15,
            "maxLength": 300,
            "description": "Single clear responsibility"
          },
          "design_patterns": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "Repository", "DAO", "Adapter", "Gateway", "Strategy",
                "Template Method", "Observer", "Pub/Sub", "Factory",
                "Builder", "Decorator", "Proxy", "Chain of Responsibility",
                "Command", "Facade", "Singleton", "MVC", "MVP", "MVVM"
              ]
            },
            "minItems": 0,
            "maxItems": 5,
            "description": "Applied design patterns"
          },
          "serves_personas": {
            "type": "array",
            "items": { "type": "string", "pattern": "^PE([1-9]|[1-9][0-9]|100)$" },
            "minItems": 0,
            "maxItems": 10,
            "description": "Product personas this component serves"
          },
          "maps_to_outcomes": {
            "type": "array",
            "items": { "type": "string", "pattern": "^O([1-9]|[1-9][0-9]|100)$" },
            "minItems": 1,
            "maxItems": 10,
            "description": "Product outcomes this component enables"
          },
          "interfaces": {
            "type": "array",
            "items": { "type": "string" },
            "maxItems": 20,
            "description": "Component interfaces"
          },
          "dependencies": {
            "type": "array",
            "items": { "type": "string" },
            "maxItems": 15,
            "description": "Dependencies on other components"
          }
        }
      }
    },

    "integrations": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "name",
          "type",
          "maps_to_product_dependency",
          "ownership",
          "contract_schema",
          "versioning_strategy",
          "backward_compatibility",
          "error_handling"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 3,
            "maxLength": 80,
            "description": "Integration name"
          },
          "type": {
            "type": "string",
            "enum": ["API", "Service", "Database", "External"],
            "description": "Integration type"
          },
          "maps_to_product_dependency": {
            "type": "string",
            "minLength": 2,
            "maxLength": 100,
            "description": "Product dependency this integration fulfills"
          },
          "ownership": {
            "type": "string",
            "enum": ["internal", "external", "shared"],
            "description": "Integration ownership"
          },
          "contract_schema": {
            "type": "string",
            "minLength": 5,
            "maxLength": 500,
            "description": "Schema definition or reference"
          },
          "versioning_strategy": {
            "type": "string",
            "enum": ["semantic", "date", "hash"],
            "description": "Versioning approach"
          },
          "backward_compatibility": {
            "type": "string",
            "enum": ["required", "optional", "none"],
            "description": "Backward compatibility requirements"
          },
          "error_handling": {
            "type": "string",
            "minLength": 10,
            "maxLength": 300,
            "description": "Error handling approach"
          },
          "compliance_requirements": {
            "type": "array",
            "items": { "type": "string", "enum": ["GDPR", "HIPAA", "PCI", "SOX", "ISO27001"] },
            "maxItems": 5,
            "description": "Compliance requirements"
          }
        }
      }
    },

    "data_strategy": {
      "type": "object",
      "additionalProperties": false,
      "required": ["persistence_approach", "data_lifecycle", "entities"],
      "properties": {
        "persistence_approach": {
          "type": "string",
          "minLength": 10,
          "maxLength": 200,
          "description": "Chosen persistence pattern"
        },
        "data_lifecycle": {
          "type": "string",
          "minLength": 10,
          "maxLength": 200,
          "description": "Data lifecycle management approach"
        },
        "entities": {
          "type": "array",
          "minItems": 1,
          "maxItems": 20,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["name", "purpose", "persistence_layer"],
            "properties": {
              "name": {
                "type": "string",
                "minLength": 3,
                "maxLength": 80,
                "description": "Entity name"
              },
              "purpose": {
                "type": "string",
                "minLength": 10,
                "maxLength": 200,
                "description": "Business purpose"
              },
              "persistence_layer": {
                "type": "string",
                "enum": ["DATABASE", "FILE", "MEMORY", "CACHE"],
                "description": "Persistence layer"
              },
              "migration_strategy": {
                "type": "string",
                "minLength": 5,
                "maxLength": 200,
                "description": "Migration approach"
              },
              "governance_rules": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "maxItems": 10,
                "description": "Data governance rules"
              },
              "quality_metrics": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "maxItems": 10,
                "description": "Data quality metrics"
              }
            }
          }
        }
      }
    },

    "security_compliance": {
      "type": "object",
      "additionalProperties": false,
      "required": ["selected_techniques", "compliance_profiles", "techniques"],
      "properties": {
        "selected_techniques": {
          "type": "array",
          "items": {
            "type": "string",
            "minLength": 3,
            "maxLength": 100
          },
          "maxItems": 20,
          "description": "Selected security techniques"
        },
        "compliance_profiles": {
          "type": "array",
          "items": { "type": "string", "enum": ["GDPR", "HIPAA", "PCI", "SOX", "ISO27001"] },
          "maxItems": 5,
          "description": "Required compliance profiles"
        },
        "techniques": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["technique", "pros", "cons", "applicability_to_product", "implementation_effort"],
            "properties": {
              "technique": {
                "type": "string",
                "minLength": 3,
                "maxLength": 100,
                "description": "Security technique name"
              },
              "pros": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "minItems": 1,
                "maxItems": 8
              },
              "cons": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 5,
                  "maxLength": 150
                },
                "minItems": 1,
                "maxItems": 8
              },
              "applicability_to_product": {
                "type": "string",
                "minLength": 15,
                "maxLength": 300,
                "description": "Why relevant to product constraints"
              },
              "implementation_effort": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Implementation effort level"
              }
            }
          }
        }
      }
    },

    "performance_targets": {
      "type": "object",
      "additionalProperties": false,
      "required": ["latency_target", "throughput_target", "maps_to_success_metrics"],
      "properties": {
        "latency_target": {
          "type": "string",
          "minLength": 5,
          "maxLength": 50,
          "description": "Target response time with measurement percentile"
        },
        "throughput_target": {
          "type": "string",
          "minLength": 5,
          "maxLength": 50,
          "description": "Requests per second target"
        },
        "concurrency_target": {
          "type": "string",
          "minLength": 5,
          "maxLength": 50,
          "description": "Concurrent users target"
        },
        "load_thresholds": {
          "type": "string",
          "minLength": 10,
          "maxLength": 200,
          "description": "Breaking point metrics and degradation thresholds"
        },
        "maps_to_success_metrics": {
          "type": "array",
          "items": { "type": "string", "pattern": "^M([1-9]|[1-9][0-9]|100)$" },
          "minItems": 1,
          "maxItems": 10,
          "description": "Product success metrics this addresses"
        }
      }
    },

    "technology_stack": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "primary_languages",
        "testing_approach",
        "justfile_required",
        "editorconfig_required",
        "language_standards"
      ],
      "properties": {
        "primary_languages": {
          "type": "array",
          "items": {
            "type": "string",
            "minLength": 2,
            "maxLength": 30
          },
          "minItems": 1,
          "maxItems": 10,
          "description": "Primary programming languages"
        },
        "frameworks": {
          "type": "array",
          "items": {
            "type": "string",
            "minLength": 2,
            "maxLength": 50
          },
          "maxItems": 20,
          "description": "Selected frameworks"
        },
        "testing_approach": {
          "type": "string",
          "pattern": ".*TDD.*",
          "minLength": 10,
          "maxLength": 100,
          "description": "Testing approach - TDD is mandatory"
        },
        "justfile_required": {
          "type": "boolean",
          "enum": [true],
          "description": "Justfile is required"
        },
        "editorconfig_required": {
          "type": "boolean",
          "enum": [true],
          "description": "EditorConfig is required"
        },
        "language_standards": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "language",
              "testing_framework",
              "linter",
              "formatter",
              "type_checker",
              "coverage_threshold"
            ],
            "properties": {
              "language": {
                "type": "string",
                "minLength": 2,
                "maxLength": 30,
                "description": "Programming language"
              },
              "testing_framework": {
                "type": "string",
                "minLength": 2,
                "maxLength": 50,
                "description": "Testing framework for this language"
              },
              "linter": {
                "type": "string",
                "minLength": 2,
                "maxLength": 50,
                "description": "Linter tool for this language"
              },
              "formatter": {
                "type": "string",
                "minLength": 2,
                "maxLength": 50,
                "description": "Code formatter for this language"
              },
              "type_checker": {
                "type": "string",
                "minLength": 2,
                "maxLength": 50,
                "description": "Type checker (if applicable)"
              },
              "coverage_threshold": {
                "type": "integer",
                "minimum": 70,
                "maximum": 100,
                "description": "Required test coverage percentage"
              }
            }
          }
        }
      }
    },

    "operational_concerns": {
      "type": "object",
      "additionalProperties": false,
      "required": ["deployment_model", "environment_strategy"],
      "properties": {
        "deployment_model": {
          "type": "object",
          "additionalProperties": false,
          "required": ["containerization", "infrastructure_as_code", "secrets_management"],
          "properties": {
            "containerization": {
              "type": "string",
              "enum": ["Docker", "Podman", "None"],
              "description": "Containerization approach"
            },
            "orchestration": {
              "type": "string",
              "enum": ["Kubernetes", "Docker Compose", "None"],
              "description": "Container orchestration"
            },
            "infrastructure_as_code": {
              "type": "string",
              "enum": ["Terraform", "Pulumi", "CloudFormation", "CDK"],
              "description": "Infrastructure as code tool"
            },
            "secrets_management": {
              "type": "string",
              "minLength": 5,
              "maxLength": 200,
              "description": "Secrets management approach"
            },
            "disaster_recovery": {
              "type": "string",
              "minLength": 10,
              "maxLength": 300,
              "description": "Disaster recovery strategy"
            }
          }
        },
        "environment_strategy": {
          "type": "object",
          "additionalProperties": false,
          "required": ["environments", "configuration_management", "monitoring_approach"],
          "properties": {
            "environments": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": ["local", "dev", "staging", "prod"]
              },
              "minItems": 4,
              "maxItems": 4,
              "uniqueItems": true,
              "description": "Required environments"
            },
            "configuration_management": {
              "type": "string",
              "minLength": 10,
              "maxLength": 200,
              "description": "How configs are managed"
            },
            "monitoring_approach": {
              "type": "string",
              "minLength": 10,
              "maxLength": 200,
              "description": "Monitoring and observability tools"
            },
            "feature_toggles": {
              "type": "string",
              "minLength": 10,
              "maxLength": 200,
              "description": "Feature flag strategy"
            }
          }
        }
      }
    },

    "traceability": {
      "type": "object",
      "additionalProperties": false,
      "required": ["mappings"],
      "properties": {
        "mappings": {
          "type": "array",
          "minItems": 1,
          "maxItems": 100,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "problem_id",
              "outcome_id",
              "tech_component",
              "test_coverage",
              "acceptance_mapping"
            ],
            "properties": {
              "problem_id": {
                "type": "string",
                "pattern": "^P([1-9]|[1-9][0-9]|100)$",
                "description": "Product problem ID"
              },
              "outcome_id": {
                "type": "string",
                "pattern": "^O([1-9]|[1-9][0-9]|100)$",
                "description": "Product outcome ID"
              },
              "tech_component": {
                "type": "string",
                "minLength": 3,
                "maxLength": 80,
                "description": "Technical component name"
              },
              "test_coverage": {
                "type": "string",
                "minLength": 15,
                "maxLength": 400,
                "description": "Test coverage description"
              },
              "acceptance_mapping": {
                "type": "string",
                "pattern": "^AC([1-9]|[1-9][0-9]|100)$",
                "description": "Acceptance criteria ID"
              }
            }
          }
        }
      }
    },

    "risk_register": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "technical_risks": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["risk_id", "description", "probability", "impact", "mitigation"],
            "properties": {
              "risk_id": {
                "type": "string",
                "pattern": "^TR([1-9]|[1-9][0-9]|100)$",
                "description": "Technical risk ID"
              },
              "description": {
                "type": "string",
                "minLength": 20,
                "maxLength": 500,
                "description": "Risk description"
              },
              "probability": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Risk probability"
              },
              "impact": {
                "type": "string",
                "enum": ["low", "medium", "high"],
                "description": "Risk impact"
              },
              "mitigation": {
                "type": "string",
                "minLength": 15,
                "maxLength": 400,
                "description": "Mitigation strategy"
              },
              "maps_to_product_risk": {
                "type": "string",
                "pattern": "^R([1-9]|[1-9][0-9]|100)$",
                "description": "Related product risk ID"
              }
            }
          }
        }
      }
    },

    "decision_log": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "adrs": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["adr_id", "title", "decision", "rationale"],
            "properties": {
              "adr_id": {
                "type": "string",
                "pattern": "^ADR([1-9]|[1-9][0-9]|[1-9][0-9][0-9]|1000)$",
                "description": "ADR identifier"
              },
              "title": {
                "type": "string",
                "minLength": 5,
                "maxLength": 150,
                "description": "Decision title"
              },
              "decision": {
                "type": "string",
                "minLength": 10,
                "maxLength": 400,
                "description": "The decision made"
              },
              "rationale": {
                "type": "string",
                "minLength": 20,
                "maxLength": 600,
                "description": "Why this decision was made"
              },
              "product_references": {
                "type": "array",
                "items": {
                  "type": "string",
                  "minLength": 3,
                  "maxLength": 100
                },
                "maxItems": 10,
                "description": "References to product.toml elements"
              },
              "version_context": {
                "type": "string",
                "minLength": 10,
                "maxLength": 200,
                "description": "Version and timeline context"
              }
            }
          }
        }
      }
    }
  },

  "additionalValidation": {
    "description": "Additional validation rules that should be checked programmatically",
    "crossReferenceRules": [
      "All problem_ids in traceability must exist in the product document",
      "All outcome_ids in traceability must exist in the product document",
      "All acceptance_mapping IDs must exist in the product document",
      "All serves_personas references must exist in the product document",
      "All maps_to_outcomes references must exist in the product document",
      "All maps_to_product_dependency references must exist in the product document",
      "All maps_to_success_metrics references must exist in the product document",
      "All tech_component references in traceability must exist in components array"
    ],
    "mandatoryRequirements": [
      "Technology stack must include TDD approach in testing_approach field",
      "Justfile and EditorConfig must be required (set to true)",
      "All language standards must have coverage thresholds >= 70%",
      "Clean Architecture principles must all be defined with project-specific applications",
      "At least one component must exist",
      "At least one traceability mapping must exist",
      "All environments [local, dev, staging, prod] must be present"
    ],
    "businessRules": [
      "Traceability must form complete chains from product problems to tech components to tests to acceptance criteria",
      "Architecture decision must include evaluation criteria and rationale with product alignment",
      "Selected security techniques must address product constraints or risks",
      "Performance targets should align with product success metrics",
      "Components should serve identified personas and map to product outcomes",
      "Integrations should fulfill identified product dependencies",
      "All principle applications should be project-specific, not generic definitions"
    ],
    "qualityAssurance": [
      "Each component should have a single, clear responsibility",
      "Architecture rationale should explicitly reference product outcomes and constraints",
      "Security techniques should include implementation effort assessment",
      "Performance targets should be specific and measurable",
      "Traceability mappings should be complete and accurate",
      "Language standards should be consistent with team capabilities",
      "Operational concerns should support scalability and reliability requirements"
    ]
  }
}
